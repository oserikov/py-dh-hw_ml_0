## Разбалловка
можно получить суммарно 10 баллов.

разбалловка:
* **5 баллов:** не выкидываются `nan`, векторизация происходит только с `countvectorizer` и никак на это повлиять нельзя, `fit()` отсутствует или недописан до хоть какого-то рабочего состояния
* **6 баллов:** всё из нормы на 5 баллов, но `fit` работает с хотя бы одним классом склёрновских классификаторов
* **7 баллов:** всё из нормы на 6 баллов, выкидываются `nan`, можно указать необходимость использовать `countvectorizer`
* **8 баллов:** всё из нормы на 7 баллов, работают `LogisticRegression` и `KNN` классификаторы из склёрна. 
  Нужные для их конструкторов параметры можно хранить где-то в приватных полях вашей обвязки.
* **9 баллов:** всё из нормы на 8 баллов, можно указать небходимость использования `fasttext` вместо векторайзеров. в случае с фасттекст-векторизацией вместо колонки с текстом появляется `размерность_фасттекст_вектора` колонок, в которые запишется фасттекст-вектор этого текста.
* **10 баллов:** всё из нормы на 9 баллов, код аккуратный, проходит кртитку PEP8, переменные хорошо названы, методы документированы докстрингами.
# Домашнее задание про датафреймы

Ваша задача -- сделать класс `DFWrapper`, оборачивающий пандасовские датафреймы (**на классификацию!**) для удобного машинного обучения на них.

В конструктор передаётся обычный датафрейм и название таргет-колонки. Гарантировано, что таргет-колонка -- на классификацию.
Если в датафрейме есть строки, содержащие `NAN`, стоит их выкинуть в самом начале конструктора и в дальнейшем работать с тем, что осталось.

у класса:
* есть `@property` метод `features(self)`:
  он отдаёт только колонки датафрейма (того, который вы обернули) которые не таргет
* в `features` 
  строковые колонки
  * категоризованы (в one hot колонки) если на всю колонку очень мало (<10%от длины колнки) разных значений (то есть кажется, что строки — это названия каких-то категорий).
    например, если у меня есть колонка "сорт винограда", то сортов наверняка не очень много и они указаны текстом. подподска
    Надо заменить её на несколько колонок (каждая соответствует одному из сортов винограда) так, что 
    в колонке стоит единица, если строка относится к соответствующему этой колонке сорту винограда и ноль -- в противном случае.
  * в противном случае векторизованы `countvectorizer`-ом, `tfidfvectorizer`-ом (или эмбеддингами fasttext(__*__)). 
    (по дефолту работает countvectorizer, необходимость использовать вместо него tfidf или эмбеддинги указывается в конструкторе вашей супер-обвязки отдельным необязательным аргументом)
* есть метод `fit()`, который принимает единственный аргумент — класс склёрновской модели, которая умеет делать классификацию (мы будем тестить на логистической регрессии и KNN), обучает модель указанного класса предсказывать `target` вашего датафрейма по features, отдаёт (`return`) обученную модель. 
для обучения модели стоит использовать весь датафрейм.

## Заметка
кажется, что фасттекстом лучше не векторизовать тексты длиннее, чем одно слово, но мы это отдельно проговорим, а пока давайте забьём.
